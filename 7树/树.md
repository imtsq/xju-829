[TOC]







# 基本概念

## 树的度

度为m的树一定有度为m的节点，但是二叉树不一定是度为2

## 叶子节点

度为零

## 路径和路径长度





# 树

## 树的遍历

- 森林有中序遍历
  - 从根节点开始，然后访问子树
  - 然后访问根
  - 在访问另一颗子树

森林中序遍历:BDEFCAIJKHG

![image-20241114163124845](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241114163124845.png)

- 树的先根：上面a树 先根遍历： abcdef（每次遍历了根就要遍历其孩子)

- 树的后根：BDEFCA(每次遍历完孩子才遍历其父亲)

  树二叉树和森林对于的遍历

  | 树（无中根 | 森林 | 二叉树 |
  | ---------- | ---- | ------ |
  | 先根遍历   | 先序 | 先     |
  | 后根遍历   | 中序 | 中     |

---

## 双亲存储

用到是顺序存储结构，parent保存的是父母的下表

```cpp
typedef struct {
    int data;
    int paren;
}PTree[MaxSize];
```

## 孩子链式存储结构

用到是数组链表，来存储孩子



## 孩子兄弟链式存储

在树转为二叉树和森林用的特别多

```cpp
typedef struct Node{
    int data;
    struct Node *lnext;
    struct Node *rnext;
}PTree[MaxSize];
```

节点左指针指向后代，又指针指向兄弟

---

# 二叉树



## 基础

- 求叶子节点
- 书高
- n个节点求二叉树高度（对比n个节点求树高
- 完全二叉树+节点数考题

---

## 树和森林转换

### 树到二叉树

用孩子兄弟方法

### 森林转二叉树

每个单个树用孩子兄弟转化为为二叉树，各个树的根作为兄弟方法链接起来（p202

### 二叉树转森林/树

孩子兄弟的逆过程



---

## 二叉树的存储

### 二叉树顺序存储p204

就是按照层序遍历依次放入顺序表中，空用‘#’表示

同时可以看看堆排序

## 链式存储

```cpp
typedef struct Node{
    int data;
    struct Node *lchild;
    struct Node *rchild; 
}BtNode;
```

---

## 二叉树遍历

### 先中后

```cpp
void  order(BtNode * tree) {
    if (!tree){
        return;
    }
    //先序
    order(tree->lchild);
    //中
    order(tree->rchild);
    //后序
}
```



看看非递归

### 层次遍历

用的队列辅助，开始将父亲装入队列，坚持队列是否空

如果不空就将队列的队头（队尾插入）元素A取出来，然后将其孩子装入队列中

---

## 二叉树的构造

### 给定序列求二叉树

- 先 + 中
  - 在先序中找到第一个A然后再中中找到A将中的A左右分为两个子树
  - 然后再子树序列中找到A中第一个，又再中序子序列中分为左右子树后面同
- 中 + 后
  - 后续最后一个A，就是中的根同先序
- 层序和中序
  - 层序第一个就是根，然后再中序中分为左右子树
  - 找到层序第二个就是子树根，

注意：前 + 后不能得到唯一的二叉树，或者不能得到二叉树

---

## 线索二叉树

- 节点的前驱后继指针叫做线索

- 线索二叉树现在一般加了头节点（n个节点最多又n + 1个空指针，有多少个指针就有多少个线索，有头节点的情况）

![image-20241017121600032](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241017121600032.png)

用空指针域来存放前后线索





## 求空链

对于二叉树：n个节点 有2n个指针域，除了根每个节点都有一个指针域指向它，那么用了n - 1个指针域，所以空

$2n - (n - 1)$

# 哈夫曼树（最优树）

考点：WPL，构造最优二叉树/哈夫曼，哈夫曼编码（概念p237，  实践p241)

## 哈夫曼编码

- 哈夫曼编码都只能在叶子节点 
- 给你n个节点问可以有多少个哈夫曼编码， 1 + （n - 1）/ 2 

## 考点：

- 前缀码：任何一个字符串不是其他字符串前缀，比如01 ，那么011就不行用了01，像这种11和011是前缀编码（从最左边开始

  - 前缀码：考点给你选择，选择不是前缀码的是

    ```
    以下哪个选项是前缀码？
    A. {00, 01, 10, 11, 001} 00 和001矛盾
    B. {0, 10, 110, 1111} 是
    C. {1, 01, 001, 000} 是
    D. {10, 100, 110, 111} 10 和 10矛盾
    
    ```

    