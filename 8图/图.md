[TOC]

---

# 图

## 有向图

节点间的方向是单向，<a,b> 和<b,a>不是同意路径

## 无向图

节点间的方向是双向

## 度

图的度 = 边数*2

- 无向图：就是顶点的度，其中图的
- 有向图：分为出度和入...

## 完全图

每两个顶点间都直接连通

- 无向完全图：边数$C_n^2$
- 有向完全图：顶点间有两条指向相反方向边 边数$C_n^2 * 2$

## 稠密图稀疏图

边多边少问题，可能考察有向图适合用什么存储方式---一般是邻接表

## 子图

并不是随便选择几个点，随便几条边都能构成子图，要子边属于图，且点集合也属于图

## 路径长度和简单路径

- 路径长度结合哈夫曼树WPL，就是经过的边个数
- 简单路径：开始和结束顶点相同外，其他节点不同（简言之：就是中间路径不形成回路）

## 回路和环

- 某条路径开始和结束是同一个点（对比上面的简单路径）

## 连通/连通分量/强连通/强连通分量

- 连通就是顶点i能不能到顶点j（图中任意一点能到其他点，就是连通的）
- 连通分量（极大的连通子图，（不是最大，相当于找到尽可能大的子图），这是争对非连通图提出，一个图中单独一个点也是连通分量，可以有多个）
- 强连通：是争对有向图，定于和连通差不多
  - 题：给你n个点的强连通图性质，和边数，就是组成一个环
- 强连通分量是争对有向图说的

## 带权图/边

结合哈夫曼树，就是边上有值了（给定权重）（实践中就是一些最短路径，工程最小花费等问题）

----

# 图的存储

## 邻接矩阵

一般用于存放稠密图，主要还是为了节省空间，对比稀疏矩阵

## 邻接表

```cpp
// 每个单独节点
typedef struct Node{
    Elemnt val;
    struct Node *next;
}Node;

//邻接表
typedef struct {
    Element data;
    Node *first;
}arrNode[maxSize];
```

 

![image-20241106121850411](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241106121850411.png)

小知识逆邻接表（有向图）

## 十字链表（一般是有向图）

![image-20241106122319603](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241106122319603.png)

- fristin是入边为它
- firstout是指向出边为它的节点
- tailvex是起点

## 邻接多重表（一般是无向图使用）

# 图的遍历

## DFS

递归/栈保存

## BFS

用队列保存

## 图的连通性判断

执行一次DFS/BFS会遍历一个（强）连通分量，如果连通每个节点都会访问，也就是visited都变号



- 所有用DFS/BFS检查

```c
int connect(AGraph *G) {
    int v = 0;
    DFS(G,v);
    for (int i = 0; i < n; i++) {
        if(visited[i] == 0) {
            //说明没访问该i节点
            return 0;
        }
    }
    return 1;
}
```



## 图是否有环

- 深度遍历：如果访问的时候，遇到了visited被访问了，证明就有环
- 拓扑排序：不能完成拓扑排序

---

# 最小生成树

个人感觉：

- 满足连通
- 整体花费值最小，比如修路，要把所有的终点串起来，那么尽可能最小的花费，和最短距离的区别是最短距离是i点到j点距离的最小值，但是我最小生成树可能i到j不是最小但是我整体最小

## 考点

- n个节点有n-1个边
- 这里是极小连通子图，有些边可以去掉，对比极大连通子图
  - 极大连通：最大可能的包含连通的点和边，
  - 极小连通子图，特点保持连通但是边尽可能少，n条顶点有n-1个边



## prim最小生成树

- A（生成最小生成树点集合）和B（原始集合）两个集合

- 初始点加入到A集合，通过新加入点更新两集合最小距离（新加入点，到B集合各点的最短距离），然后找出A集合到B集合最小距离的点（从更新的最短距离判断），加入A集合，更新

- 依次重复
- 最终求得n顶点和n-1条边 

这里可以结合dijkstra学习算法感觉差不多只是更新最小边，一个更新是距离

## 克鲁斯卡尔

- 通过找边集合，每次找最短距离，且不构成回路

---

# 最短距离

## dijkstra

其实和prim有相似的地方

- prime：每次通过找当前两个集合最短

  ```c
  //k表示当前是k加入集合A
  for(i....){
      //join看是否加入A, 后面是求出集合新加入点和原来集合最短距离
  	if(join[i] = 0 && dist[i] > graph[k][i])   {} 
  }
  
  ```

- dijkstra：每次找源点到各个顶点的最短距离，更新的是原点到其他各个顶点的距离

  ```c
  //k表示当前是k加入集合A
  for(i....){
      //join看是否加入A, 后面就不一样了，相当于a到c点，假如当前是b点看a->c和a->b->c求出最短距离
  	if(join[i] = 0 && dist[i] > graph[k][i] + dist[i])    {}
  }
  
  ```

  

## floyd(每对点间的最小距离)

```c
for( k ){
    for( i ) {
        for( j ) {
            //通过中间节点K来更新
            /*
            i -> j
            i -> k ->j
            */
            if (A[i][j] > A[i][k] + A[k][j]) {
                A[i][j] = A[i][k] + A[k][j];
                path[i][j] = A[i][k] + A[k][j]
            }
        }
    } 
}
```



---

# 拓扑排序

对一个有向图中找拓扑序列的过程叫做拓扑排序

又叫顶点表示活动（AOV)

执行是没有入度的时候，就可以执行这个顶点活动，相当于每次查找入度为零的点



# AOE网和关键路径✨

这里用边表示活动

- 只有一个开始点(源点)一个结束点(汇点)
- 如果又多个开始或者多个结束,比如多个开始,一般是补充一个点然后补充点指向多个开始点作为新源点

## 关键路径和关键活动

关键路径:从远源点到汇点所有路径的最长路劲,(完成工程的最短时间就是AOE网的关键路劲长度)

<font color="red">注意</font>这里的最长路径是说我完成这条路径,其他活动也会完成,如果你选择了另一条路径假如耗时5分钟,但是还有路径要耗时10分钟,就有路径没完成这个项目就没结束,这里的最长就是这个意思,    最短的理解就是也学还有其他回路这种,

- 这里最长是相对多条路径同一个汇点选择一条最长（相对于多条路径来说）
- 最短路径，就是你关键路径满足条件直接执行，不停留，因为你能无限停留（相对于关键路径来说）

总结就是一句换,要让其他活动也能完成,选这种路径的最短路径就是关键路径

## 关键活动

关键路径上所有的活动

对比AOV这里连线是活动,点是事件



## 考题：

给你一个AOE网，求给个点的Ve(最早开始时间)，Vl（最晚开始时间）各个活动最早和最晚开始开始时间

![image-20241116203202997](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241116203202997.png)

### Ve节点最快执行时间

- 对于普通点：

如Ve(B) = Ve(A) + a1; 等于上一个点加上活动时间

- 对于一个汇点：

其时间等于，如Ve(E) = Max(Ve(B) + a4, Ve(c) + a5);  选取前面分值最值，符合关键路径

### Vl节点最晚执行时间

这个做法只能和Ve相反，找到最后汇点的关键路径要都时间，然后分别减

这里关键路径要18， 那么

- Vl（F) = Vl(I) - a10;   Vl(G) = Vl(I) - a11
- 对于某分值点
  - 如Vl（E) = Min(Vl(F) - a7, Vl(G) - a8);
