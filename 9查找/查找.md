[TOC]

---

# 折半查找

- 注意查找失败的ASL计算，不是该失败节点的层数而是它的父亲节点





# 二叉排序树查找

二叉搜索树 /二叉排序树

左边小，又大原则，和根节点比较（考察：1给定序列构造一个二叉搜索树，2结合其他遍历（其实还是考构造））



其实感觉就是对二分查找的拓展

ASL和折半查找同

- 二叉排序树的删除
  - 删除叶子节点，不管
  - 删除只有左子树或者只有右子树，让它左或者右子树来替代它
  - 删除既有左又有右子树节点
    - 找到右子树最小的节点（最左下的节点）来替代它，其中最好要搞左子树最大的（小提示最排序树进行中序能得到一个有序序列）

  其中中序遍历能得到有序序列

  ---

  

# 平衡二叉树

## 添加

### LL

当插入使得某个节点A的平衡因子为2（绝对值），那么就A节点儿子节点作为父亲，因为A儿子介于A和添加的节点间

### RR

同ll

### LR

某个节点A因为子树添加了节点，使得不平衡，就不能直接使用LL和RR的方法，这里有拐，按摩A节点的儿子节点就不是介于两个节点间的值，

- 如下图，当添加了6号节点7号节点平衡因子绝对值为2，是7号节点左子树的右节点引起，那么就看5号节点（只是从7号往下两层），
- 5号父亲当左孩子，7号当有孩子6号做7号孩子

<img src="C:\Users\tsqcn\AppData\Roaming\Typora\typora-user-images\image-20241207183345568.png" alt="image-20241207183345568" style="zoom:50%;" />

### RL

差不多lr



方法就是早第一个失去平衡因子的，看添加构成什么形状

## 删除



## 查找





# B树

其实就是二叉排序树的拓展

- 树种最多的分值m，就是m差树，（每个节点的关键字个数比分支树少一，最多也没m  - 1,因为m叉树最多是m个分支
- 为保证查找效率，出根节点每个节点至少要有$m/2$向上取整个数的分支，关键字个数至少就是  $m/2$向上取整 - 1
- 可以是空树
- 外部节点在同一层，就是没查询到的

---

# 哈希表

- 存储：通过哈希表将关键字映射为内存地址，
- 查询：存储的逆过程（但是会遇到一些哈希冲突的情况，通过解决冲突的设计来规避

## 构造哈希函数

- 直接定地址 
- 除留余数法： m%n =地址 (其中n不大于哈希表长度的素数比较好，比如边长10 n可以去7 5)

## 解决哈希冲突

### 1开放定址法：

找一个新的空间

- 线性探测法

  d = (d + 1) mod m

- 平方探测法

  $d = (d + i^2)$ mod  m
  
  括号里面持续d + 1， d - 1, $d + 2^2$, $d - 2^2$....当然都要 mod m

### 2空间拉链法

有点像邻接表，同义词（相同的哈希地址）用链表串联

## ALS

首先哈希表部分具有顺序表的直接存取性（为发生冲突的部分）找到的次数为1，一部分要找，找到次数为多少就多少

- 成功简简单单
- 不成功看书p355难以解释





## 辨析

让你设计一个哈希表时，总长度不一定等于关键字个数，可以等于或者大于，看题怎么给条件

- 给你关键字个数n个，说装填因子为多少比如0.6， 那么哈希表长为n/0.6
- 然后如果是开放地址法 - 平方探测又不一样，具体问题具体分析![image-20241118171918798](https://cdn.jsdelivr.net/gh/imtsq/My_Pic/image-20241118171918798.png)